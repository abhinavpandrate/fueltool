/**
 * STYRKR BYOB Prefill Bridge  (v2 — Recharge SDK edition)
 * ─────────────────────────────────────────────────────────
 * Loaded on: https://styrkr.com/products/build-your-own-bundle
 *
 * PURPOSE
 * ────────
 * Read ?prefill=<base64url(JSON)> from the URL and auto-select
 * the athlete's pack quantities in the native Recharge Bundles widget.
 *
 * TWO STRATEGIES (tried in order)
 * ────────────────────────────────
 * 1. RECHARGE SDK  (preferred)
 *    If `window.STYRKR_VARIANT_MAP` is loaded on this page too, we can call
 *    `recharge.bundle.getBundleId()` and immediately redirect the customer to
 *    /cart/add.js — bypassing the widget UI entirely.
 *    This is the "express prefill" or "1-click subscribe" flow.
 *    Set `window.STYRKR_PREFILL_MODE = 'express'` to activate this.
 *
 * 2. DOM WIDGET MANIPULATION  (default / fallback)
 *    Finds each pack row in the Recharge bundle widget by collectionId / product
 *    handle / display text, then clicks the + button or sets the qty input.
 *    Uses a MutationObserver + polling loop because the widget hydrates async.
 *
 * PAYLOAD FORMAT
 * ──────────────
 * Generated by buildByobPrefillUrl() in app.js:
 * {
 *   "v": 1,
 *   "generatedAt": "2026-02-20T12:34:56.000Z",
 *   "planner": { ... },
 *   "lines": [
 *     { "packKey": "GEL30_12", "qty": 2 },
 *     { "packKey": "MIX90_12", "qty": 1 }
 *   ]
 * }
 *
 * INSTALLATION
 * ────────────
 * Add to your Shopify theme as a snippet loaded on the build-your-own-bundle
 * product page template only. Load AFTER the Recharge theme script.
 *
 * Optional: also load assets/variant_map.js before this file to enable
 * express mode.
 */

(function () {
  'use strict';

  // ── 1. Parse the prefill payload ──────────────────────────────────────────

  const params  = new URLSearchParams(window.location.search);
  const token   = params.get('prefill');
  if (!token) return;

  function base64UrlDecode(b64url) {
    const b64  = b64url.replace(/-/g, '+').replace(/_/g, '/') + '==='.slice((b64url.length + 3) % 4);
    const bin  = atob(b64);
    const bytes = Uint8Array.from(bin, (c) => c.charCodeAt(0));
    return new TextDecoder().decode(bytes);
  }

  let payload;
  try {
    payload = JSON.parse(base64UrlDecode(token));
  } catch (e) {
    console.warn('[STYRKR Prefill] Invalid payload:', e);
    return;
  }

  if (!payload || !Array.isArray(payload.lines) || payload.lines.length === 0) return;

  window.__STYRKR_PREFILL__ = payload;  // expose for debugging

  const lines = payload.lines.filter((l) => l && l.packKey && Number(l.qty) > 0);
  if (lines.length === 0) return;

  console.info('[STYRKR Prefill] Payload parsed. Lines:', lines.map(l => l.packKey + '×' + l.qty).join(', '));

  // ── 2. Express mode (Recharge SDK + variant map) ───────────────────────────
  // Skips the widget UI and adds directly to cart.
  // Only fires if:
  //   (a) STYRKR_PREFILL_MODE === 'express'  AND
  //   (b) STYRKR_VARIANT_MAP is loaded        AND
  //   (c) STYRKR_RECHARGE is loaded (recharge_checkout.js)

  if (
    window.STYRKR_PREFILL_MODE === 'express' &&
    window.STYRKR_VARIANT_MAP  &&
    window.STYRKR_RECHARGE
  ) {
    // We need to reconstruct a bundle object that matches what addRechargeBundle expects.
    // Map packKeys from the prefill payload to fake bundle.lines format.
    const fakeBundleLines = lines.map((l) => ({ packKey: l.packKey, qty: l.qty }));
    const fakeBundle      = { lines: fakeBundleLines };

    console.info('[STYRKR Prefill] Express mode: adding to cart via Recharge SDK…');

    const statusEl = document.querySelector('[data-styrkr-prefill-status]');
    window.STYRKR_RECHARGE.addRechargeBundle(
      fakeBundle,
      /* subscribe */ true,
      (msg, isErr) => {
        if (statusEl) statusEl.textContent = msg;
        if (isErr) console.error('[STYRKR Prefill express]', msg);
      }
    );

    return; // Don't also run the DOM strategy
  }

  // ── 3. DOM widget manipulation (default strategy) ─────────────────────────
  //
  // Recharge's native Bundle widget renders product cards with +/- quantity
  // controls. The widget is a Vue/React app that loads asynchronously.
  //
  // SELECTOR STRATEGY (in priority order per pack card)
  // ─────────────────────────────────────────────────────
  //  a) data-variant-id="<variantId>"  ← only if variant_map.js is loaded
  //  b) data-product-handle="<handle>" ← Recharge often stamps this
  //  c) [href*="<handle>"] inside the card
  //  d) visible text scan matching the packKey or pack_option label
  //
  // QUANTITY SETTING (in priority order)
  // ─────────────────────────────────────
  //  1) input[type="number"] or input.rc-bundle__qty-input  (direct value set)
  //  2) [data-action="increase"] / button[aria-label*="increase" i]  (click loop)
  //  3) [data-action="add"] on the card to select it first, then +

  // ── Build a handle→packKey lookup if variant_map is available ──
  const MAP      = window.STYRKR_VARIANT_MAP;
  const packKeys = new Set(lines.map((l) => l.packKey));

  // Build packKey → desired qty
  const qtyWanted = {};
  for (const l of lines) qtyWanted[l.packKey] = Number(l.qty);

  // Build variantId → packKey (for data-variant-id selector)
  const variantToPackKey = {};
  if (MAP && MAP.packs) {
    for (const [pk, entry] of Object.entries(MAP.packs)) {
      if (packKeys.has(pk)) variantToPackKey[String(entry.variantId)] = pk;
    }
  }

  // ── Build URL handle → packKey mapping from data.js packs (available in window)
  // data.js is also loaded on the Shopify page via the theme since app.js references it.
  // We'll use a URL-handle heuristic: extract the last path segment from the pack url.
  const handleToPackKey = {};
  const DATA = window.STYRKR_DATA;
  if (DATA && DATA.packs) {
    for (const [pk, packData] of Object.entries(DATA.packs)) {
      if (!packKeys.has(pk)) continue;
      try {
        const url    = packData.url || '';
        const handle = url.split('/products/')[1]?.split(/[?#]/)[0]?.split('/')[0]
                    || url.split('/collections/')[1]?.split(/[?#]/)[0]?.split('/')[0];
        if (handle) handleToPackKey[handle] = pk;
      } catch (_) {}
    }
  }

  // ── Utility: find a pack card in the widget DOM ──
  function findCardForPackKey(packKey) {
    // a) variant ID data attribute (most reliable when variant_map is loaded)
    if (MAP && MAP.packs && MAP.packs[packKey]) {
      const vid = String(MAP.packs[packKey].variantId);
      if (vid !== 'FILL_ME_IN') {
        const el = document.querySelector(`[data-variant-id="${vid}"]`)
                || document.querySelector(`[data-product-variant-id="${vid}"]`);
        if (el) return el.closest('.rc-bundle__product, .bundle-product, li, article, [data-product]') || el.parentElement;
      }
    }

    // b) handle via href
    for (const [handle, pk] of Object.entries(handleToPackKey)) {
      if (pk !== packKey) continue;
      const link = document.querySelector(`a[href*="/products/${handle}"], a[href*="/collections/"][href*="${handle}"]`);
      if (link) return link.closest('.rc-bundle__product, .bundle-product, li, article, [data-product]') || link.parentElement;
    }

    // c) pack_option text scan (e.g. "6 pack", "12 pack")
    const packOption = (DATA && DATA.packs && DATA.packs[packKey] && DATA.packs[packKey].pack_option) || '';
    if (packOption) {
      const candidates = Array.from(document.querySelectorAll('.rc-bundle__product, .bundle-product, li, article, [data-product]'));
      const hit = candidates.find((el) => el.textContent.includes(packOption) && el.textContent.includes(packKey.split('_')[0]));
      if (hit) return hit;
    }

    // d) raw packKey text
    const all = Array.from(document.querySelectorAll('*'));
    const textHit = all.find((el) => (el.textContent || '').trim() === packKey && el.children.length === 0);
    if (textHit) return textHit.closest('.rc-bundle__product, .bundle-product, li, article, [data-product]') || textHit.parentElement;

    return null;
  }

  // ── Utility: read current qty from a card ──
  function getCurrentQty(card) {
    const input = card.querySelector('input[type="number"], input.rc-bundle__qty-input, input[data-qty]');
    if (input) return Number(input.value) || 0;
    const display = card.querySelector('[data-qty], .qty, .quantity, [data-quantity]');
    if (display) return Number(display.textContent) || 0;
    return 0;
  }

  // ── Utility: set qty in a card ──
  function setQty(card, targetQty) {
    // Try direct input first
    const input = card.querySelector(
      'input[type="number"], input.rc-bundle__qty-input, input[name*="quantity"], input[data-qty]'
    );
    if (input) {
      const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;
      nativeInputValueSetter.call(input, String(targetQty));
      input.dispatchEvent(new Event('input',  { bubbles: true }));
      input.dispatchEvent(new Event('change', { bubbles: true }));
      return true;
    }

    // Otherwise use + / - buttons
    const plusBtn = card.querySelector(
      '[data-action="increase"], [data-action="add-one"], button[aria-label*="increase" i], button[aria-label*="plus" i], button[aria-label*="add" i], button[class*="plus" i], button[class*="increase" i], .rc-bundle__qty-btn--plus'
    );
    const minusBtn = card.querySelector(
      '[data-action="decrease"], [data-action="remove-one"], button[aria-label*="decrease" i], button[aria-label*="minus" i], button[aria-label*="remove" i], button[class*="minus" i], button[class*="decrease" i], .rc-bundle__qty-btn--minus'
    );

    const current = getCurrentQty(card);
    const delta   = targetQty - current;
    if (delta === 0) return true;

    const btn = delta > 0 ? plusBtn : minusBtn;
    if (!btn) return false;

    // If card is not yet "selected" (qty = 0 and there's an add/select button), click that first
    if (current === 0 && delta > 0) {
      const selectBtn = card.querySelector('[data-action="select"], [data-action="add"], button[class*="add" i], button[class*="select" i], .rc-bundle__add-btn');
      if (selectBtn && !plusBtn) { selectBtn.click(); }
    }

    for (let i = 0; i < Math.abs(delta); i++) {
      btn.click();
    }
    return true;
  }

  // ── Main apply function ──
  function applyPrefill() {
    let applied = 0;
    for (const line of lines) {
      const card = findCardForPackKey(line.packKey);
      if (!card) {
        console.warn('[STYRKR Prefill] Could not find widget card for:', line.packKey);
        continue;
      }
      const ok = setQty(card, Number(line.qty));
      if (ok) {
        applied++;
        console.info('[STYRKR Prefill] Set', line.packKey, '→', line.qty);
      } else {
        console.warn('[STYRKR Prefill] Could not set qty for:', line.packKey, '— no input or +/- buttons found.');
      }
    }
    console.info('[STYRKR Prefill] Done. Applied', applied + '/' + lines.length, 'lines.');
  }

  // ── Wait for the Recharge widget to finish rendering ──
  // The widget is async-hydrated; we watch for known container selectors.

  const WIDGET_SELECTORS = [
    '.rc-bundle',
    '.rc-bundle__products',
    '[data-bundle-widget]',
    '#bundle-widget',
    '.bundle-builder',
    '#bundle-builder',
    'form[action*="/cart/add"]',
  ];

  function isWidgetReady() {
    return WIDGET_SELECTORS.some((s) => document.querySelector(s));
  }

  // MutationObserver approach — faster than polling on slow connections
  let applied = false;
  const observer = new MutationObserver(() => {
    if (!applied && isWidgetReady()) {
      applied = true;
      observer.disconnect();
      // Small delay to let Vue/React finish its render pass after the container appears
      setTimeout(applyPrefill, 400);
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });

  // Fallback polling in case MutationObserver misses a fast initial render
  const MAX_WAIT   = 15000;
  const start      = Date.now();
  const pollTimer  = setInterval(() => {
    if (applied || Date.now() - start > MAX_WAIT) {
      clearInterval(pollTimer);
      if (!applied) {
        console.warn('[STYRKR Prefill] Widget not found after', MAX_WAIT, 'ms. Attempting anyway.');
        applyPrefill();
      }
      return;
    }
    if (isWidgetReady()) {
      applied = true;
      clearInterval(pollTimer);
      observer.disconnect();
      setTimeout(applyPrefill, 400);
    }
  }, 300);

})();
